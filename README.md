Лабораторная работа №7

Тема лабораторной работы: Преобразование и анализ кода с использованием Clang и LLVM.

Цель работы: Познакомиться с инструментами Clang и LLVM, научиться собирать AST и IR-промежуточное представление кода на C/C++, а также извлекать базовую информацию о программе.

Задание: 

1. Установить Clang и LLVM;

2. Скомпилировать простой C-файл с использованием clang и получить его: абстрактное синтаксическое дерево (AST), промежуточное представление LLVM IR;

3. Использовать opt для применения базовой комплексной оптимизации (например, О2);

4. Построить граф потока управления (CFG) для оптимизированной программы;

5. Проанализировать результат, сделать выводы и ответить на контрольные вопросы.

Установить Clang и LLVM:

Работа выполнялась в среде Ubuntu 22.04. Установлены следующие инструменты:

clang — компилятор языка C/C++.

llvm — инструменты анализа и оптимизации кода.

opt — инструмент для работы с LLVM IR и применения оптимизаций.

Graphviz — инструмент для визуализации кода.

Команда установки:

sudo apt install clang llvm

![image](https://github.com/user-attachments/assets/863f46fb-f8fc-4631-9a4e-ef2c206b873e)

C-файл:

![image](https://github.com/user-attachments/assets/2cbb7781-42de-4a88-aef6-a5a662de46fb)

Абстрактное синтаксическое дерево (AST):

Команда:

clang -Xclang -ast-dump -fsyntax-only main.c

![image](https://github.com/user-attachments/assets/b5d9cd7e-c228-49f5-9ec4-3b30d95ba117)

Функция square принята, содержит параметр x и возвращает x * x.

Генерация LLVM IR:

Команда для генерации LLVM IR:

clang -S -emit-llvm main.c -o main.ll

![image](https://github.com/user-attachments/assets/fbefc686-f7b9-47f6-ba04-01a8f40c29f2)

Оптимизация IR:

Команда для генерации неоптимизированного IR:

clang -O0 -S -emit-llvm main.c -o main_O0.ll

Отметим, что в файле с IR до оптимизации:

Все переменные (a, b, x.addr) размещены в памяти через alloca;

Множество операций load и store;

square вызывается как отдельная функция.

![image](https://github.com/user-attachments/assets/96f89363-461b-4849-a7c7-e2c074b5074b)

Команда для генерации оптимизированного IR с уровнем -O2:

clang -O2 -S -emit-llvm main.c -o main_O2.ll

Команда -O2 – комплексная оптимизация среднего уровня. Она применяет более 30 различных оптимизаций:

-inline – встраивание небольших функций (встраивает square в main, если она вызывается один раз);

-constprop – подставит значение square(5) → 25, если функция встроена и всё известно на этапе компиляции;

-mem2reg – перевод переменных из памяти в регистры (SSA);

-instcombine – объединение и упрощение инструкций (упростит арифметику, например x * x может быть преобразовано в shl при x = 2^n);

-simplifycfg – оптимизирует структуру блоков (упростит граф управления, если после inlining останутся лишние блоки);

-reassociate, -gvn, -sroa, -dce и другие.

![image](https://github.com/user-attachments/assets/af2bb48a-b5f0-4dab-84bc-284284f509f5)

Команда для сравнения IR до и после оптимизации:

diff main_O0.ll main_O2.ll

![image](https://github.com/user-attachments/assets/acad1388-75b8-47a3-aa02-81b8a9ca2036)

![image](https://github.com/user-attachments/assets/713aeb2b-5407-4cdf-a7d6-559e9768ed23)

после оптимизации произошли следующие изменения:

Переменные типа alloca были удалены;

Код переведён в SSA-форму.

Граф потока управления:

Команда для генерации оптимизированного LLVM IR:

clang -O2 -S -emit-llvm main.c -o main.ll

Команда для генерации .dot-файлов CFG для функций:

 opt -dot-cfg -disable-output main.ll

![image](https://github.com/user-attachments/assets/4d36a648-473c-4cb0-947b-b97a4826fef3)

![image](https://github.com/user-attachments/assets/86561ed1-eb30-4745-b453-4c0d29001683)

В LLVM каждый граф потока управления (CFG) строится на уровне функции, поскольку структура управления всегда локальна для тела функции. Для получения полного представления о программе, нужно построить CFG для всех функций и анализировать их совокупность. Автоматическое объединение всех CFG в один граф не предусмотрено в LLVM по умолчанию.

Ответы на контрольные вопросы:

1. Что такое Clang, и какова его роль в процессе компиляции программ?

Clang — это фронтенд компилятора для языков C, C++, Objective-C и других, разработанный в рамках проекта LLVM. Его основная задача — преобразование исходного кода в абстрактное синтаксическое дерево (AST), а затем в промежуточное представление (IR), которое передаётся в дальнейшие фазы компиляции. Clang также проверяет синтаксис и семантику программы, выдаёт диагностические сообщения и может генерировать как объектный код, так и LLVM IR или ассемблер.

2. Что представляет собой LLVM и как он используется в современных компиляторах?

LLVM (Low Level Virtual Machine) — это инфраструктура для построения компиляторов и инструментов анализа программ. Она предоставляет промежуточное представление (LLVM IR), оптимизационные и генераторные этапы компиляции, позволяя использовать одни и те же бэкенды для разных языков. Современные компиляторы (например, Clang, Rust, Swift) используют LLVM как основу для генерации эффективного и переносимого машинного кода, а также для реализации мощных оптимизаций.

3. Чем отличается абстрактное синтаксическое дерево (AST) от промежуточного представления LLVM IR?

AST (абстрактное синтаксическое дерево) — это структурированное представление исходного кода, отражающее его грамматическую структуру, но без лишней синтаксической информации. Оно используется на ранних этапах компиляции для анализа и трансформации кода. LLVM IR — это низкоуровневое промежуточное представление, близкое к машинному коду, но независимое от архитектуры. В отличие от AST, оно включает явное управление потоком исполнения и переменными, что делает его удобным для оптимизаций и генерации машинного кода.

4. Для чего необходимо промежуточное представление (IR) в процессе компиляции?

Промежуточное представление (IR) служит мостом между высокоуровневым языком программирования и машинным кодом. Оно обеспечивает унифицированную основу для анализа, трансформации и оптимизации программного кода. Благодаря независимости от исходного языка и целевой платформы, IR позволяет использовать одни и те же оптимизационные алгоритмы и генераторы кода для разных языков и архитектур, упрощая разработку компиляторов и повышая эффективность компиляции.

5. Что делает инструкция alloca в LLVM IR, и зачем она используется в функциях?

Инструкция alloca в LLVM IR используется для выделения памяти в стеке функции на время её выполнения. Она создаёт область памяти для локальной переменной, к которой затем можно обращаться через указатели. Эта инструкция полезна для реализации автоматических переменных, временных буферов и передачи данных между блоками внутри функции. Память, выделенная alloca, автоматически освобождается при выходе из функции, аналогично работе локальных переменных в языке C.

6. Зачем нужна оптимизация кода в компиляторе, и какие основные цели она преследует?

Оптимизация кода в компиляторе направлена на улучшение характеристик скомпилированной программы без изменения её функциональности. Основные цели включают увеличение скорости выполнения, снижение потребления памяти, уменьшение размера исполняемого файла, повышение энергоэффективности и улучшение использования аппаратных ресурсов. Оптимизации могут быть высокоуровневыми (например, устранение мёртвого кода) или низкоуровневыми (например, размещение переменных в регистрах).

7. Что такое SSA-форма и почему она важна при оптимизации программ?

SSA (Static Single Assignment) — это форма представления промежуточного кода, при которой каждая переменная присваивается только один раз. При каждом новом присваивании создаётся новая версия переменной. Это упрощает анализ зависимостей, позволяет легко определить, какие значения используются и где, и существенно облегчает реализацию оптимизаций, таких как удаление мёртвого кода, распространение копий и свёртывание выражений.

8. Что такое граф потока управления (CFG) и как он помогает анализировать поведение программы?

Граф потока управления (Control Flow Graph, CFG) — это ориентированный граф, в котором вершины представляют базовые блоки (непрерывные последовательности инструкций без ветвлений), а рёбра указывают возможные переходы управления между блоками. CFG позволяет анализировать структуру программы: циклы, условия, блоки без выхода. Он является основой для множества оптимизаций и анализов, таких как определение доступных выражений, доминаторов и живых переменных.

9. Как устроено представление арифметических операций в LLVM IR (например, умножение, сложение)?

В LLVM IR арифметические операции представлены в виде трёхадресных инструкций. Каждая операция указывается явно с операндами и типами. Например, add i32 %a, %b означает сложение двух 32-битных целых значений, а mul i32 %x, 10 — умножение переменной на константу. Такое представление делает код удобным для анализа и упрощает последующую оптимизацию, так как все операции типизированы и независимы от архитектуры.

10. Почему функции в LLVM IR обычно представляют собой отдельные единицы анализа и оптимизации?

Функции в LLVM IR обособлены, потому что это упрощает локальный анализ и оптимизацию. Каждую функцию можно рассматривать как самостоятельный граф (CFG), что позволяет применять к ней различные трансформации без необходимости учитывать весь остальной код. Также это позволяет проводить инлайнинг (встраивание функций) и удаление неиспользуемых функций, анализируя только точки вызова.

11. Что происходит с функцией в LLVM IR, если она вызывается один раз и очень короткая?

Если функция в LLVM IR вызывается один раз и является короткой, оптимизатор обычно применяет инлайнинг — заменяет вызов функции её телом прямо в вызывающем коде. Это позволяет избавиться от накладных расходов на вызов, улучшить анализ кода и расширить возможности для последующих оптимизаций, таких как устранение избыточных переменных и упрощение выражений.

12. Какие преимущества даёт использование IR и CFG для автоматических оптимизаций по сравнению с анализом исходного текста на C?

Использование IR и CFG даёт более формальное, структурированное и однозначное представление программы по сравнению с исходным кодом на C, где могут быть макросы, нестандартизованные конструкции и зависимость от контекста. IR устраняет синтаксическую неоднозначность, упрощает анализ зависимостей и упрощает применение трансформаций. CFG делает управление потоком явным и доступным для графового анализа, что критически важно для точных и эффективных оптимизаций.
